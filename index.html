<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COSC 102 - How to Test Your Code</title>
    <link rel="stylesheet" href="assets/css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <header>
        <div class="logo">
            <h1>COSC 102 Testing Guide</h1>
        </div>
        <nav id="main-nav">
            <ul>
                <li><a href="#home" class="active" data-page="home"><i class="fas fa-home"></i> Home</a></li>
                <li><a href="#overview" data-page="overview"><i class="fas fa-map"></i> 4-Step Approach</a></li>
                <li><a href="#example1" data-page="example1"><i class="fas fa-1"></i> Example 1</a></li>
                <li><a href="#example2" data-page="example2"><i class="fas fa-2"></i> Example 2</a></li>
                <li><a href="#example3" data-page="example3"><i class="fas fa-3"></i> Example 3</a></li>
                <li><a href="#advanced" data-page="advanced"><i class="fas fa-code"></i> Advanced</a></li>
            </ul>
        </nav>
        <button id="theme-toggle">
            <i class="fas fa-moon"></i>
        </button>
    </header>
    
    <main>
        <!-- Home Page -->
        <section id="home" class="page active">
            <div class="hero">
                <div class="hero-content">
                    <h2>Learn How to Test Your Code</h2>
                    <p>A comprehensive guide for COSC 102 students</p>
                </div>
            </div>
            
            <div class="motivation">
                <h2>Testing Philosophy?</h2>
                <div class="card-container">
                    <div class="card">
                        <div class="card-icon"><i class="fas fa-question-circle"></i></div>
                        <h3>Why</h3>
                        <p>Have you ever been caught off guard by a bug with no clear origin or fix? The assignment is due in 20 minutes, panic sets in, and you know your grade is about to take a hit. Testing changes that. By integrating test suites while writing your code, you create a clearer and more coherent understanding of what your program is doing, and when something goes wrong, you'll know exactly where to look. Testing isn't just for catching mistakes, instead it gives you confidence that your code works as expected and helps document its intended behavior for yourself and others.</p>
                    </div>
                    <div class="card">
                        <div class="card-icon"><i class="fas fa-clock"></i></div>
                        <h3>When</h3>
                        <p>You should start testing as soon as you begin outlining your code. The moment you understand what your program is supposed to achieve is the moment you can begin designing meaningful tests. Testing early lets you identify edge cases and confirm that the core logic works as intended while you build. That way, if you refactor or update your code later, your pre-written tests serve as a safety net, quickly catching any unintended changes before they become serious problems.</p>
                    </div>
                    <div class="card">
                        <div class="card-icon"><i class="fas fa-cogs"></i></div>
                        <h3>How</h3>
                        <p>Ensure that you understand both the inputs and outputs of your code very clearly. Ask yourself: What are the boundaries of the input? What are the distinctions between different input categories? Are all lines of code and all conditional branches being exercised by your tests? By consistently asking these kinds of questions, you'll define your input and output space thoroughly and ensure that every line of your code is doing exactly what it's supposed to.</p>
                    </div>
                </div>
            </div>
            
            <div class="cta">
                <h2>Ready to Learn More?</h2>
                <button class="btn-primary" id="get-started">Get Started</button>
            </div>
        </section>
        
        <!-- 4-Step Overview Page -->
        <section id="overview" class="page">
            <div class="approach-intro">
                <h2>Our 4-Step Testing Approach</h2>
                <div class="intro-content">
                    <p>The testing approaches detailed in this project, Boundary Value Testing (BVT), Equivalence Class Testing (ECT), and Line/Branch Coverage, are designed to directly target the most common loop and boundary errors students encounter in COSC 102. These techniques were intentionally ordered to build progressively: starting with simple boundary testing, moving to strategies that partition the input or output space, and culminating in ensuring full line and branch coverage. Each method adds a new layer of insight into how thoroughly your code is tested.</p>
                    <p>This sequence provides a structural sweep of your code, ensuring it's not only functionally correct but also robust against edge cases and overlooked logic. To minimize redundancy in test cases, we introduced slight variations across the techniques, allowing students to achieve high coverage with relatively low effort.</p>
                </div>
            </div>
            <h2>The 4 Steps</h2>
            <div class="step-overview">
                <div class="step">
                    <div class="step-number">1</div>
                    <h3>Robust Boundary-Value Tests</h3>
                    <p>Filter valid vs invalid cases</p>
                    <button class="btn-secondary expand-details" data-section="section1">Learn More</button>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <h3>Edge-Focused Weak Normal Equivalence-Class Test</h3>
                    <p>Cover the valid outputs</p>
                    <button class="btn-secondary expand-details" data-section="section2">Learn More</button>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <h3>Structural Coverage Sweep</h3>
                    <p>Hunt for blind spots</p>
                    <button class="btn-secondary expand-details" data-section="section3">Learn More</button>
                </div>
                <div class="step">
                    <div class="step-number">4</div>
                    <h3>Suite Refinement</h3>
                    <p>Keep what matters, drop the rest</p>
                    <button class="btn-secondary expand-details" data-section="section4">Learn More</button>
                </div>
            </div>
            
            <!-- Expandable Sections -->
            <div class="expandable-sections">
                <div id="section1" class="section-content hidden">
                    <h3>Robust Boundary-Value Tests - Filter Valid vs Invalid</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>This approach primarily follows a "guard the gate" strategy. The idea is to rigorously test the transitions between different behavioral conditions by examining values at and around the boundary points of input ranges. These boundaries often represent moments where the program's logic flips, from accepting to rejecting, from true to false, or from one output to another. Testing right at these borders helps confirm that the logic changes when and where it should.</p>

                            <p>This is especially important when working with numeric or ordered inputs, where subtle errors, like off-by-one mistakes or incorrect inequality signs, can cause unexpected or inconsistent behavior. Boundary Value Testing doesn't just aim to catch invalid inputs; it ensures the program behaves predictably and correctly around the edges of decision-making logic.</p>

                            <h4>Systematic Testing Framework</h4>
                            <p>To apply this strategy, we systematically test six values per input variable:</p>

                            <div class="boundary-values">
                                <div class="boundary-value">
                                    <span class="boundary-label">Min - 1:</span>
                                    <span class="boundary-desc">Just below the allowed minimum (should be rejected or behave differently)</span>
                                </div>
                                <div class="boundary-value">
                                    <span class="boundary-label">Min:</span>
                                    <span class="boundary-desc">The exact lower boundary (should be accepted)</span>
                                </div>
                                <div class="boundary-value">
                                    <span class="boundary-label">Min + 1:</span>
                                    <span class="boundary-desc">Just above the lower boundary (should be accepted)</span>
                                </div>
                                <div class="boundary-value">
                                    <span class="boundary-label">Max - 1:</span>
                                    <span class="boundary-desc">Just below the upper boundary (should be accepted)</span>
                                </div>
                                <div class="boundary-value">
                                    <span class="boundary-label">Max:</span>
                                    <span class="boundary-desc">The exact upper boundary (should be accepted)</span>
                                </div>
                                <div class="boundary-value">
                                    <span class="boundary-label">Max + 1:</span>
                                    <span class="boundary-desc">Just above the allowed maximum (should be rejected or behave differently)</span>
                                </div>
                            </div>

                            <p class="insight">This pattern helps verify that the program consistently transitions between states at the correct thresholds and fails gracefully when inputs cross those boundaries. If the program unexpectedly accepts an out-of-range value or rejects a valid boundary value, it likely indicates a logic error that needs further investigation. This systematic method provides clarity and confidence in your program's behavior, especially around critical decision points.</p>
                        </div>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="section2" class="section-content hidden">
                    <h3>Edge-Focused Weak Normal Equivalence-Class Tests - Cover Valid Outputs</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>The goal of Equivalence Class Testing (ECT) is to verify that a program behaves correctly across distinct categories of input. Rather than testing every possible value, ECT simplifies the process by dividing the input space into groups, called equivalence classes, where all members of a class are expected to produce the same output or behavior. The underlying assumption is that if one representative value from a class behaves correctly, the rest will too. This allows you to reduce the number of test cases while still covering the full range of program behavior.</p>

                            <p>While Boundary Value Testing (BVT) focuses on verifying behavior at the edges of individual conditions, ECT complements this by identifying the broader logic that governs those conditions. Instead of testing just around where the program changes behavior (as in BVT), ECT targets the reason why behavior changes. It helps you define the conditions themselves—mapping out where one class of logic flips to another. In this way, ECT simplifies the challenge of designing BVT cases: once the equivalence classes are defined, you know exactly where transitions occur and where to apply more fine-grained boundary checks.</p>

                            <h4>Implementation Strategy</h4>
                            <p>To implement ECT effectively, follow these three steps:</p>

                            <div class="ect-steps">
                                <div class="ect-step">
                                    <div class="step-number">1</div>
                                    <div class="step-content">
                                        <h5>Partition the input space</h5>
                                        <p>For each input parameter, identify valid and invalid ranges where inputs produce the same type of outcome. Group these into equivalence classes, each defined by producing a unique behavior or result.</p>
                                    </div>
                                </div>

                                <div class="ect-step">
                                    <div class="step-number">2</div>
                                    <div class="step-content">
                                        <h5>Select representative values</h5>
                                        <p>Choose values from each equivalence class that represent the typical or defining behavior of that class. Unlike BVT, the goal isn't to test just inside and outside of a boundary but to test values within each class.</p>
                                    </div>
                                </div>

                                <div class="ect-step">
                                    <div class="step-number">3</div>
                                    <div class="step-content">
                                        <h5>Form test case tuples</h5>
                                        <p>If your function takes multiple inputs, create test cases that combine representatives from different equivalence classes. The goal is to ensure that every combination of classes is tested at least once, providing broad behavioral coverage without unnecessary repetition.</p>
                                    </div>
                                </div>
                            </div>

                            <p class="insight">By designing tests around these representative values and class combinations, you can validate both typical and edge-case behavior while keeping your test suite efficient and targeted. When used alongside BVT, ECT gives you both a high-level map of program logic and the tools to probe its weak points with precision.</p>
                        </div>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="section3" class="section-content hidden">
                    <h3>Structural Coverage Sweep - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>[Detailed content about hunting for blind spots in test coverage]</p>

                            <h4>Key Concepts</h4>
                            <ul>
                                <li>Code coverage identifies untested execution paths</li>
                                <li>Statement coverage: ensure every line runs at least once</li>
                                <li>Branch coverage: ensure every decision (if/else) is tested</li>
                                <li>Path coverage: ensure all possible execution paths are tested</li>
                                <li>Finding blind spots leads to discovering untested edge cases</li>
                            </ul>
                        </div>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="section4" class="section-content hidden">
                    <h3>Suite Refinement - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>[Detailed content about refining test suites]</p>
                            
                            <h4>Key Refinement Strategies</h4>
                            <ul>
                                <li>Eliminate redundant tests that cover the same cases</li>
                                <li>Prioritize tests based on importance and risk</li>
                                <li>Remove tests that don't add value or coverage</li>
                                <li>Combine similar tests for efficiency</li>
                                <li>Organize tests for better maintainability</li>
                            </ul>
                        </div>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="section5" class="section-content hidden">
                    <h3>Approach Limitations in Context</h3>
                    <p class="limitations-intro">Our 4-step approach excels at systematically testing functional correctness, but like all methods, it has specific limitations to consider when planning your testing strategy.</p>

                    <div class="limitations-grid">
                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-chart-line fa-2x"></i>
                            </div>
                            <h4>Coverage ≠ Completeness</h4>
                            <p>Line/branch coverage only proves every path ran. If you overlook a boundary or mis-group an equivalence class, the suite could still pass while bugs lurk untested. This suite is designed to provide generally sufficient coverage with minimal cases.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> Boundary analysis, equivalence partitioning
                            </div>
                        </div>

                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-tasks fa-2x"></i>
                            </div>
                            <h4>Manual Effort Can Scale Rapidly</h4>
                            <p>Drawing boundaries, classes, and crafting extra cases for uncovered branches is quick on small methods but grows increasingly time-consuming with larger functions or deep nesting. We can see the complexity grow quickly with 40 cases for the classify method. While properly written functions should be single-responsibility and lightweight, automated generators or coverage tools can still become necessary.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> Automated test generators, coverage tools
                            </div>
                        </div>

                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-cubes fa-2x"></i>
                            </div>
                            <h4>Object-Oriented Programming is Nuanced</h4>
                            <p>Once students reach classes and inheritance, bugs often depend on object state, call sequences, or subclass overrides. The template's single-call focus must be extended to cover those interactions.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> State-based testing, integration testing
                            </div>
                        </div>

                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-server fa-2x"></i>
                            </div>
                            <h4>Non-Functional and External Concerns</h4>
                            <p>Performance, randomness, file I/O, and networking calls are not covered by this workflow. Properly testing code that uses these practices may require more complex methods such as mocking. In practice, dependencies that require mocking are present in more advanced code, typically outside the scope of 102 assignments.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> Mocking, performance testing, specialized frameworks
                            </div>
                        </div>
                    </div>

                    <p class="limitations-conclusion">By understanding these limitations, you can better determine when to apply this 4-step approach and when to complement it with other testing strategies for comprehensive quality assurance.</p>

                    <button class="btn-primary section-close">Close</button>
                </div>
            </div>
            
            <div class="cta">
                <h2>Ready to See It in Action?</h2>
                <button class="btn-primary" id="see-in-action">See It In Action</button>
            </div>
            
            <div class="limitations-section">
                <h2>Understanding Approach Limitations</h2>
                <p>Even the best testing approaches have constraints. Being aware of these limitations helps you supplement with other testing methods when necessary.</p>
                <div class="limitations-preview">
                    <div class="limitation-preview-item">
                        <i class="fas fa-chart-line"></i>
                        <p>Coverage ≠ Completeness</p>
                    </div>
                    <div class="limitation-preview-item">
                        <i class="fas fa-tasks"></i>
                        <p>Manual Effort Scaling</p>
                    </div>
                    <div class="limitation-preview-item">
                        <i class="fas fa-cubes"></i>
                        <p>OOP Complexity</p>
                    </div>
                    <div class="limitation-preview-item">
                        <i class="fas fa-server"></i>
                        <p>External Dependencies</p>
                    </div>
                </div>
                <button class="btn-secondary expand-details" data-section="section5">Explore Limitations in Detail</button>
            </div>
        </section>
        
        <!-- Example 1 Page -->
        <section id="example1" class="page">
            <h2>Example 1: Calculator Function</h2>
            <div class="example-overview">
                <p>In this example, we'll walk through the process of testing a simple calculator addition function using our 4-step approach.</p>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">0</div>
                    <h3>Understanding Requirements</h3>
                </div>
                <div class="step-content">
                    <p>For our calculator addition function, we need to understand exactly what it should do:</p>
                    
                    <ul>
                        <li>Take two integer inputs</li>
                        <li>Return their sum as an integer</li>
                        <li>Handle positive numbers, negative numbers, and zero</li>
                        <li>Handle overflow according to Java integer rules</li>
                    </ul>
                    
                    <div class="code-example">
                        <h4>The Function We're Testing</h4>
                        <pre><code>
public class Calculator {
    /**
     * Adds two numbers
     * @param a first number
     * @param b second number
     * @return sum of a and b
     */
    public int add(int a, int b) {
        return a + b;
    }
}
                        </code></pre>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3>Step 1: Robust Boundary-Value Tests</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we identify the boundaries where behavior might change and test around those boundaries:</p>
                    
                    <ul>
                        <li>We consider the range of valid inputs (all integers)</li>
                        <li>We identify boundaries such as zero, positive/negative transitions</li>
                        <li>We look at extreme values like Integer.MAX_VALUE and Integer.MIN_VALUE</li>
                        <li>We create test cases that focus on these boundary conditions</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 1</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Boundary Being Tested</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>BVT1</td>
                                <td>Zero boundary - both zero</td>
                                <td>a=0, b=0</td>
                                <td>0</td>
                                <td>Zero values</td>
                            </tr>
                            <tr>
                                <td>BVT2</td>
                                <td>Zero boundary - one zero</td>
                                <td>a=5, b=0</td>
                                <td>5</td>
                                <td>One zero operand</td>
                            </tr>
                            <tr>
                                <td>BVT3</td>
                                <td>Maximum value boundary</td>
                                <td>a=Integer.MAX_VALUE, b=1</td>
                                <td>Exception expected</td>
                                <td>Overflow threshold</td>
                            </tr>
                            <tr>
                                <td>BVT4</td>
                                <td>Minimum value boundary</td>
                                <td>a=Integer.MIN_VALUE, b=-1</td>
                                <td>Exception expected</td>
                                <td>Underflow threshold</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3>Step 2: Edge-Focused Weak Normal Equivalence-Class Test</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we create test cases that represent different categories of valid input and expected output behaviors:</p>
                    
                    <ul>
                        <li>We identify distinct categories of equivalent input scenarios (positive + positive, negative + negative, etc.)</li>
                        <li>We choose representative values from each category</li>
                        <li>We ensure all normal (valid) behaviors are covered</li>
                        <li>We focus on covering fundamental behaviors rather than all possible inputs</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 2</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Equivalence Class</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>EC1</td>
                                <td>Both positive</td>
                                <td>a=5, b=3</td>
                                <td>8</td>
                                <td>Positive + Positive</td>
                            </tr>
                            <tr>
                                <td>EC2</td>
                                <td>Both negative</td>
                                <td>a=-2, b=-7</td>
                                <td>-9</td>
                                <td>Negative + Negative</td>
                            </tr>
                            <tr>
                                <td>EC3</td>
                                <td>Positive + Negative (|a| > |b|)</td>
                                <td>a=10, b=-5</td>
                                <td>5</td>
                                <td>Mixed signs, positive result</td>
                            </tr>
                            <tr>
                                <td>EC4</td>
                                <td>Positive + Negative (|a| < |b|)</td>
                                <td>a=5, b=-10</td>
                                <td>-5</td>
                                <td>Mixed signs, negative result</td>
                            </tr>
                            <tr>
                                <td>EC5</td>
                                <td>Equal magnitude opposite signs</td>
                                <td>a=7, b=-7</td>
                                <td>0</td>
                                <td>Mixed signs, zero result</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3>Step 3: Structural Coverage Sweep</h3>
                </div>
                <div class="step-content">
                    <p>Using JaCoCo to analyze our code coverage, we identified additional test cases needed:</p>
                    
                    <ul>
                        <li>Test case for Integer.MAX_VALUE boundary: a=Integer.MAX_VALUE, b=1</li>
                        <li>Test case for Integer.MIN_VALUE boundary: a=Integer.MIN_VALUE, b=-1</li>
                        <li>Test case for overflow detection</li>
                    </ul>
                    
                    <div class="placeholder-image">
                        <p>[JaCoCo coverage results image will be added here]</p>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <h3>Step 4: Suite Refinement</h3>
                </div>
                <div class="step-content">
                    <p>After reviewing all our test cases, we've refined our test suite to the following essential tests:</p>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Test Case</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>T1</td>
                                <td>Basic positive</td>
                                <td>a=5, b=3</td>
                                <td>8</td>
                                <td>Core functionality</td>
                            </tr>
                            <tr>
                                <td>T2</td>
                                <td>Both negative</td>
                                <td>a=-2, b=-7</td>
                                <td>-9</td>
                                <td>Sign handling</td>
                            </tr>
                            <tr>
                                <td>T3</td>
                                <td>Mixed signs</td>
                                <td>a=10, b=-5</td>
                                <td>5</td>
                                <td>Sign handling</td>
                            </tr>
                            <tr>
                                <td>T4</td>
                                <td>MAX_VALUE boundary</td>
                                <td>a=MAX_VALUE, b=1</td>
                                <td>Exception</td>
                                <td>Overflow detection</td>
                            </tr>
                            <tr>
                                <td>T5</td>
                                <td>MIN_VALUE boundary</td>
                                <td>a=MIN_VALUE, b=-1</td>
                                <td>Exception</td>
                                <td>Underflow detection</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <p>We eliminated redundant zero-handling tests as they didn't add significant value to the test suite.</p>
                </div>
            </div>
            
            <div class="example-conclusion">
                <h3>Example Summary</h3>
                <p>Our systematic 4-step approach allowed us to create a robust test suite for the calculator function. We identified key boundary conditions and provided essential test coverage while eliminating redundant tests.</p>
            </div>
            
            <div class="cta">
                <button class="btn-primary next-example" data-next="example2">Next Example</button>
            </div>
        </section>
        
        <!-- Example 2 Page -->
        <section id="example2" class="page">
            <h2>Example 2: String Validator</h2>
            <div class="example-overview">
                <p>In this example, we'll apply our 4-step approach to test a string validation function that checks if a string meets certain criteria.</p>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">0</div>
                    <h3>Understanding Requirements</h3>
                </div>
                <div class="step-content">
                    <p>For our string validator, we need to understand the validation rules:</p>
                    
                    <ul>
                        <li>String must be between 8 and 20 characters long</li>
                        <li>String must contain at least one uppercase letter</li>
                        <li>String must contain at least one digit</li>
                        <li>String must not contain spaces</li>
                    </ul>
                    
                    <div class="code-example">
                        <h4>The Function We're Testing</h4>
                        <pre><code>
public class StringValidator {
    /**
     * Validates a string according to specific rules
     * @param input the string to validate
     * @return true if the string is valid, false otherwise
     */
    public boolean isValid(String input) {
        // Check length
        if (input == null || input.length() < 8 || input.length() > 20) {
            return false;
        }
        
        // Check for uppercase letter
        boolean hasUppercase = false;
        // Check for digit
        boolean hasDigit = false;
        // Check for spaces
        boolean hasSpace = false;
        
        for (char c : input.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUppercase = true;
            }
            if (Character.isDigit(c)) {
                hasDigit = true;
            }
            if (Character.isWhitespace(c)) {
                hasSpace = true;
            }
        }
        
        return hasUppercase && hasDigit && !hasSpace;
    }
}
                        </code></pre>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3>Step 1: Robust Boundary-Value Tests</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we focus on testing the boundaries specified in the requirements:</p>
                    
                    <ul>
                        <li>We test the minimum and maximum length boundaries (8 and 20 characters)</li>
                        <li>We test exactly at the boundaries (8 characters, 20 characters)</li>
                        <li>We test just outside the boundaries (7 characters, 21 characters)</li>
                        <li>We test special cases like null input</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 1</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Boundary Being Tested</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>BVT1</td>
                                <td>Null input</td>
                                <td>null</td>
                                <td>false</td>
                                <td>Special null case</td>
                            </tr>
                            <tr>
                                <td>BVT2</td>
                                <td>Exactly minimum length</td>
                                <td>"Abcde123" (8 chars)</td>
                                <td>true</td>
                                <td>Minimum length boundary</td>
                            </tr>
                            <tr>
                                <td>BVT3</td>
                                <td>Just under minimum length</td>
                                <td>"Abcde12" (7 chars)</td>
                                <td>false</td>
                                <td>Below minimum length</td>
                            </tr>
                            <tr>
                                <td>BVT4</td>
                                <td>Exactly maximum length</td>
                                <td>"Abcdefghij1234567890" (20 chars)</td>
                                <td>true</td>
                                <td>Maximum length boundary</td>
                            </tr>
                            <tr>
                                <td>BVT5</td>
                                <td>Just over maximum length</td>
                                <td>"Abcdefghij12345678901" (21 chars)</td>
                                <td>false</td>
                                <td>Above maximum length</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3>Step 2: Edge-Focused Weak Normal Equivalence-Class Test</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we create test cases for different categories of valid and invalid inputs based on the other requirements:</p>
                    
                    <ul>
                        <li>We test combinations of requirements (uppercase, digit, no spaces)</li>
                        <li>We create tests for each failing condition</li>
                        <li>We ensure all validation rules are individually tested</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 2</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Equivalence Class</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>EC1</td>
                                <td>Valid input - all requirements met</td>
                                <td>"Password123"</td>
                                <td>true</td>
                                <td>Valid string</td>
                            </tr>
                            <tr>
                                <td>EC2</td>
                                <td>Missing uppercase letter</td>
                                <td>"password123"</td>
                                <td>false</td>
                                <td>Missing uppercase requirement</td>
                            </tr>
                            <tr>
                                <td>EC3</td>
                                <td>Missing digit</td>
                                <td>"PasswordTest"</td>
                                <td>false</td>
                                <td>Missing digit requirement</td>
                            </tr>
                            <tr>
                                <td>EC4</td>
                                <td>Contains space</td>
                                <td>"Password 123"</td>
                                <td>false</td>
                                <td>Contains forbidden character</td>
                            </tr>
                            <tr>
                                <td>EC5</td>
                                <td>Special characters (allowed)</td>
                                <td>"P@ssw0rd#$!"</td>
                                <td>true</td>
                                <td>Valid with special characters</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3>Step 3: Structural Coverage Sweep</h3>
                </div>
                <div class="step-content">
                    <p>Using JaCoCo to analyze our code coverage, we identified additional test cases needed:</p>
                    
                    <ul>
                        <li>Test case where only the space check fails (other conditions pass)</li>
                        <li>Test case for input with both uppercase and digits but no other requirements</li>
                        <li>Test for early return conditions in sequence</li>
                    </ul>
                    
                    <div class="placeholder-image">
                        <p>[JaCoCo coverage results image will be added here]</p>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <h3>Step 4: Suite Refinement</h3>
                </div>
                <div class="step-content">
                    <p>After reviewing all our test cases, we've refined our test suite to the following essential tests:</p>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>RT1</td>
                                <td>Valid string</td>
                                <td>"Password123"</td>
                                <td>true</td>
                                <td>Valid case verification</td>
                            </tr>
                            <tr>
                                <td>RT2</td>
                                <td>Null input</td>
                                <td>null</td>
                                <td>false</td>
                                <td>Special case handling</td>
                            </tr>
                            <tr>
                                <td>RT3</td>
                                <td>Length boundary - too short</td>
                                <td>"Abc1"</td>
                                <td>false</td>
                                <td>Minimum length verification</td>
                            </tr>
                            <tr>
                                <td>RT4</td>
                                <td>Length boundary - too long</td>
                                <td>"Abcdefghij1234567890X"</td>
                                <td>false</td>
                                <td>Maximum length verification</td>
                            </tr>
                            <tr>
                                <td>RT5</td>
                                <td>Missing uppercase</td>
                                <td>"password123"</td>
                                <td>false</td>
                                <td>Uppercase requirement</td>
                            </tr>
                            <tr>
                                <td>RT6</td>
                                <td>Missing digit</td>
                                <td>"PasswordTest"</td>
                                <td>false</td>
                                <td>Digit requirement</td>
                            </tr>
                            <tr>
                                <td>RT7</td>
                                <td>Contains space</td>
                                <td>"Password 123"</td>
                                <td>false</td>
                                <td>No-space requirement</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <p>We eliminated some redundant test cases and focused on a minimal set that still provides 100% code coverage.</p>
                </div>
            </div>
            
            <div class="example-conclusion">
                <h3>Example Summary</h3>
                <p>Our systematic 4-step approach allowed us to create a comprehensive test suite for the string validator. We identified key validation boundaries and provided complete coverage of all validation rules while avoiding redundant tests.</p>
            </div>
            
            <div class="cta">
                <button class="btn-primary next-example" data-next="example3">Next Example</button>
            </div>
        </section>
        
        <!-- Example 3 Page -->
        <section id="example3" class="page">
            <h2>Example 3: File Processing Library</h2>
            <div class="example-overview">
                <p>In this example, we'll apply our 4-step approach to test a file processing library that reads and processes data files.</p>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">0</div>
                    <h3>Understanding Requirements</h3>
                </div>
                <div class="step-content">
                    <p>For our file processing library, we need to understand the requirements:</p>
                    
                    <ul>
                        <li>Must read CSV files with comma-separated values</li>
                        <li>Must handle empty files and files with headers</li>
                        <li>Must convert string data to appropriate types (integers, doubles)</li>
                        <li>Must handle file errors gracefully (file not found, permission denied)</li>
                        <li>Must allow filtering and sorting of data</li>
                    </ul>
                    
                    <div class="code-example">
                        <h4>The Class We're Testing</h4>
                        <pre><code>
public class CSVProcessor {
    /**
     * Reads a CSV file and returns processed data
     * @param filePath the path to the CSV file
     * @param hasHeader whether the file has a header row
     * @return DataTable containing the processed data
     * @throws IOException if there's an error reading the file
     */
    public DataTable readCSV(String filePath, boolean hasHeader) throws IOException {
        File file = new File(filePath);
        if (!file.exists() || !file.canRead()) {
            throw new IOException("File does not exist or cannot be read: " + filePath);
        }
        
        DataTable table = new DataTable();
        BufferedReader reader = new BufferedReader(new FileReader(file));
        
        // Read header if present
        String line = reader.readLine();
        if (line == null) {
            reader.close();
            return table; // Empty file
        }
        
        if (hasHeader) {
            String[] headers = line.split(",");
            table.setHeaders(headers);
            line = reader.readLine();
        }
        
        // Read data rows
        while (line != null) {
            String[] values = line.split(",");
            table.addRow(values);
            line = reader.readLine();
        }
        
        reader.close();
        return table;
    }
    
    // Other methods for filtering, sorting, etc.
}
                        </code></pre>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3>Step 1: Robust Boundary-Value Tests</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we identify boundary conditions for our CSV processor:</p>
                    
                    <ul>
                        <li>File existence and access boundaries (exists vs doesn't exist, readable vs not readable)</li>
                        <li>File content boundaries (empty file, single line, very large file)</li>
                        <li>Header presence boundary (with header vs without header)</li>
                        <li>Special case boundaries (malformed data, invalid paths)</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 1</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Boundary Being Tested</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>BVT1</td>
                                <td>File doesn't exist</td>
                                <td>"nonexistent.csv", true</td>
                                <td>IOException</td>
                                <td>File existence boundary</td>
                            </tr>
                            <tr>
                                <td>BVT2</td>
                                <td>Empty file</td>
                                <td>"empty.csv", true</td>
                                <td>Empty DataTable</td>
                                <td>Empty content boundary</td>
                            </tr>
                            <tr>
                                <td>BVT3</td>
                                <td>Single line file with header</td>
                                <td>"singleline.csv", true</td>
                                <td>DataTable with headers, no data</td>
                                <td>Minimum content with header</td>
                            </tr>
                            <tr>
                                <td>BVT4</td>
                                <td>Single line file without header</td>
                                <td>"singleline.csv", false</td>
                                <td>DataTable with one data row</td>
                                <td>Minimum content without header</td>
                            </tr>
                            <tr>
                                <td>BVT5</td>
                                <td>No read permission</td>
                                <td>"nopermission.csv", true</td>
                                <td>IOException</td>
                                <td>File permission boundary</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3>Step 2: Edge-Focused Weak Normal Equivalence-Class Test</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we identify categories of valid inputs and design one test case for each category:</p>
                    
                    <ul>
                        <li>We categorize different valid file formats and content types</li>
                        <li>We test representative files from each category</li>
                        <li>We ensure normal operation cases are covered</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 2</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Equivalence Class</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>EC1</td>
                                <td>Standard CSV with header</td>
                                <td>"standard.csv", true</td>
                                <td>DataTable with headers and rows</td>
                                <td>Standard CSV with header</td>
                            </tr>
                            <tr>
                                <td>EC2</td>
                                <td>Standard CSV without header</td>
                                <td>"standard.csv", false</td>
                                <td>DataTable with rows, no headers</td>
                                <td>Standard CSV without header</td>
                            </tr>
                            <tr>
                                <td>EC3</td>
                                <td>CSV with numeric data only</td>
                                <td>"numeric.csv", true</td>
                                <td>DataTable with numeric values</td>
                                <td>Numeric data CSV</td>
                            </tr>
                            <tr>
                                <td>EC4</td>
                                <td>CSV with text data only</td>
                                <td>"text.csv", true</td>
                                <td>DataTable with text values</td>
                                <td>Text data CSV</td>
                            </tr>
                            <tr>
                                <td>EC5</td>
                                <td>CSV with mixed data types</td>
                                <td>"mixed.csv", true</td>
                                <td>DataTable with mixed values</td>
                                <td>Mixed data CSV</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3>Step 3: Structural Coverage Sweep</h3>
                </div>
                <div class="step-content">
                    <p>Using JaCoCo to analyze our code coverage, we identified additional test cases needed:</p>
                    
                    <ul>
                        <li>Test case with malformed CSV (inconsistent column count)</li>
                        <li>Test case with special characters in CSV data</li>
                        <li>Test case for the file reading exception handling paths</li>
                    </ul>
                    
                    <div class="placeholder-image">
                        <p>[JaCoCo coverage results image will be added here]</p>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <h3>Step 4: Suite Refinement</h3>
                </div>
                <div class="step-content">
                    <p>After reviewing all our test cases, we've refined our test suite to the following essential tests:</p>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>RT1</td>
                                <td>Valid file with header</td>
                                <td>"data.csv", true</td>
                                <td>Correct DataTable</td>
                                <td>Basic functionality with header</td>
                            </tr>
                            <tr>
                                <td>RT2</td>
                                <td>Valid file without header</td>
                                <td>"data.csv", false</td>
                                <td>Correct DataTable</td>
                                <td>Basic functionality without header</td>
                            </tr>
                            <tr>
                                <td>RT3</td>
                                <td>Empty file</td>
                                <td>"empty.csv", true</td>
                                <td>Empty DataTable</td>
                                <td>Empty file handling</td>
                            </tr>
                            <tr>
                                <td>RT4</td>
                                <td>File not found</td>
                                <td>"nonexistent.csv", true</td>
                                <td>IOException</td>
                                <td>Error handling</td>
                            </tr>
                            <tr>
                                <td>RT5</td>
                                <td>Malformed CSV</td>
                                <td>"malformed.csv", true</td>
                                <td>Exception or handling</td>
                                <td>Malformed data handling</td>
                            </tr>
                            <tr>
                                <td>RT6</td>
                                <td>File with special characters</td>
                                <td>"special.csv", true</td>
                                <td>Correct DataTable</td>
                                <td>Special character handling</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <p>We eliminated redundant test cases focusing on a minimal set that ensures all execution paths are covered.</p>
                </div>
            </div>
            
            <div class="example-conclusion">
                <h3>Example Summary</h3>
                <p>Our systematic 4-step approach allowed us to create a robust test suite for the CSV processor. We identified boundary conditions, provided comprehensive coverage of both normal and error cases, and developed effective error handling strategies.</p>
            </div>
        </section>
        
        <!-- Advanced Page - Maven & JaCoCo Blog-Style -->
        <section id="advanced" class="page">
            <h2>Advanced Testing Tools</h2>
            <div class="example-overview">
                <p>Setting up a robust testing environment is essential for effective test-driven development. Learn how to leverage Maven and JaCoCo to streamline your testing workflow.</p>
            </div>

            <div class="approach-step blog-post">
                <div class="blog-header">
                    <h3>Maven & JaCoCo: Your Complete Testing Toolkit</h3>
                </div>

                <div class="blog-content">
                    <p>Maven is the build engine that fetches your dependencies, compiles your code, runs every JUnit test, and—thanks to the bundled JaCoCo plug‑in—spits out a line‑by‑line coverage report in HTML. Getting that toolchain wired up from scratch can be a headache, but don't worry, we've got you covered.</p>

                    <h4>Quick Start Guide</h4>
                    <div class="steps-container">
                        <div class="step-item">
                            <div class="step-icon"><i class="fas fa-code-branch"></i></div>
                            <div class="step-content">
                                <h5>1. Clone the Repository</h5>
                                <p>Clone the ready‑made harness at <a href="https://github.com/jon-cook1/102-coverage" target="_blank">https://github.com/jon-cook1/102-coverage</a> into the folder that sits next to your lab.</p>
                                <div class="code-example">
                                    <pre><code>git clone https://github.com/jon-cook1/102-coverage</code></pre>
                                </div>
                            </div>
                        </div>

                        <div class="step-item">
                            <div class="step-icon"><i class="fas fa-cogs"></i></div>
                            <div class="step-content">
                                <h5>2. Set Up the Testing Environment</h5>
                                <p>Run the setup script once to configure the testing environment for your lab.</p>
                                <div class="code-example">
                                    <pre><code>./setup_tests.sh ../YourLabFolder</code></pre>
                                </div>
                            </div>
                        </div>

                        <div class="step-item">
                            <div class="step-icon"><i class="fas fa-vial"></i></div>
                            <div class="step-content">
                                <h5>3. Run Your Tests</h5>
                                <p>After the initial setup, just call the run script whenever you want fresh results.</p>
                                <div class="code-example">
                                    <pre><code>./run_tests.sh</code></pre>
                                </div>
                            </div>
                        </div>

                        <div class="step-item">
                            <div class="step-icon"><i class="fas fa-sync-alt"></i></div>
                            <div class="step-content">
                                <h5>4. Testing a Different Project</h5>
                                <p>Need to test a different project? Just rerun the setup script with the new folder path.</p>
                                <div class="code-example">
                                    <pre><code>./setup_tests.sh ../NewLabFolder</code></pre>
                                </div>
                                <p class="note"><i class="fas fa-info-circle"></i> Note: Changing labs wipes the tests already inside the harness, because this beta is meant as a quick‑start demo rather than a permanent test repository.</p>
                            </div>
                        </div>
                    </div>

                    <div class="info-box">
                        <div class="info-icon"><i class="fas fa-lightbulb"></i></div>
                        <div class="info-content">
                            <h4>How It Works</h4>
                            <p>The 102-coverage harness automates the entire testing process:</p>
                            <ul>
                                <li>Configures Maven to work with your Java project</li>
                                <li>Sets up JUnit test execution</li>
                                <li>Integrates JaCoCo for code coverage analysis</li>
                                <li>Generates HTML reports showing your test coverage</li>
                                <li>Provides a simple interface to run and view test results</li>
                            </ul>
                            <p>Full step‑by‑step instructions are available in the repo's README.</p>
                        </div>
                    </div>

                    <div class="tool-showcase">
                        <div class="tool-item">
                            <div class="tool-icon"><i class="fas fa-box"></i></div>
                            <h4>Maven</h4>
                            <p>Industry-standard build tool that manages dependencies, compiles code, and runs tests with a simple command.</p>
                        </div>

                        <div class="tool-item">
                            <div class="tool-icon"><i class="fas fa-chart-pie"></i></div>
                            <h4>JaCoCo</h4>
                            <p>Code coverage library that shows exactly which lines of your code are tested and which are not, with intuitive visual reports.</p>
                        </div>
                    </div>

                </div>
            </div>

            <div class="cta">
                <h3>Ready to Improve Your Test Coverage?</h3>
                <div class="button-container">
                    <a href="https://github.com/jon-cook1/102-coverage" target="_blank" class="btn-primary">
                        <i class="fas fa-code-branch"></i> Go to Repository
                    </a>
                    <a href="https://github.com/jon-cook1/102-coverage#readme" target="_blank" class="btn-secondary">
                        <i class="fas fa-book"></i> View Setup Instructions
                    </a>
                </div>
            </div>
        </section>
    </main>
    
    <footer>
        <div class="footer-content">
            <p>&copy; 2025 COSC 102 Testing Guide</p>
            <p>Created for educational purposes</p>
        </div>
    </footer>
    
    <script src="assets/js/main.js"></script>
</body>
</html>