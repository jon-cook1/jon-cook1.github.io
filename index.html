<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COSC 102 - How to Test Your Code</title>
    <link rel="stylesheet" href="assets/css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <header>
        <div class="logo">
            <h1>COSC 102 Testing Guide</h1>
        </div>
        <nav id="main-nav">
            <ul>
                <li><a href="#home" class="active" data-page="home"><i class="fas fa-home"></i> Home</a></li>
                <li><a href="#overview" data-page="overview"><i class="fas fa-map"></i> 4-Step Approach</a></li>
                <li><a href="#example1" data-page="example1"><i class="fas fa-1"></i> Example 1</a></li>
                <li><a href="#example2" data-page="example2"><i class="fas fa-2"></i> Example 2</a></li>
                <li><a href="#example3" data-page="example3"><i class="fas fa-3"></i> Example 3</a></li>
                <li><a href="#advanced" data-page="advanced"><i class="fas fa-code"></i> Advanced</a></li>
            </ul>
        </nav>
        <button id="theme-toggle">
            <i class="fas fa-moon"></i>
        </button>
    </header>
    
    <main>
        <!-- Home Page -->
        <section id="home" class="page active">
            <div class="hero">
                <div class="hero-content">
                    <h2>Learn How to Test Your Code</h2>
                    <p>A comprehensive guide for COSC 102 students</p>
                </div>
                <div class="hero-image">
                    <!-- Placeholder for main image -->
                    <div class="placeholder-image">
                        <i class="fas fa-code fa-5x"></i>
                        <p>Main Image Placeholder</p>
                    </div>
                </div>
            </div>
            
            <div class="motivation">
                <h2>Testing Philosophy?</h2>
                <div class="card-container">
                    <div class="card">
                        <div class="card-icon"><i class="fas fa-question-circle"></i></div>
                        <h3>Why</h3>
                        <p>Have you ever been caught off guard by a bug with no clear origin or fix? The assignment is due in 20 minutes, panic sets in, and you know your grade is about to take a hit. Testing changes that. By integrating test suites while writing your code, you create a clearer and more coherent understanding of what your program is doing, and when something goes wrong, you’ll know exactly where to look. Testing isn’t just for catching mistakes, instead it gives you confidence that your code works as expected and helps document its intended behavior for yourself and others.
                        </p>
                    </div>
                    <div class="card">
                        <div class="card-icon"><i class="fas fa-clock"></i></div>
                        <h3>When</h3>
                        <p>You should start testing as soon as you begin outlining your code. The moment you understand what your program is supposed to achieve is the moment you can begin designing meaningful tests. Testing early lets you identify edge cases and confirm that the core logic works as intended while you build. That way, if you refactor or update your code later, your pre-written tests serve as a safety net, quickly catching any unintended changes before they become serious problems.
                        </p>
                    </div>
                    <div class="card">
                        <div class="card-icon"><i class="fas fa-cogs"></i></div>
                        <h3>How</h3>
                        <p>Ensure that you understand both the inputs and outputs of your code very clearly. Ask yourself: What are the boundaries of the input? What are the distinctions between different input categories? Are all lines of code and all conditional branches being exercised by your tests? By consistently asking these kinds of questions, you’ll define your input and output space thoroughly and ensure that every line of your code is doing exactly what it’s supposed to.
                        </p>
                    </div>
                </div>
            </div>
            
            <div class="cta">
                <h2>Ready to Learn More?</h2>
                <button class="btn-primary" id="get-started">Get Started</button>
            </div>
        </section>
        
        <!-- 4-Step Overview Page -->
        <section id="overview" class="page">
            <h2>Our 4-Step Testing Approach</h2>
            <div class="step-overview">
                <div class="step">
                    <div class="step-number">1</div>
                    <h3>Robust Boundary-Value Tests</h3>
                    <p>Filter valid vs invalid cases</p>
                    <button class="btn-secondary expand-details" data-section="section1">Learn More</button>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <h3>Edge-Focused Weak Normal Equivalence-Class Test</h3>
                    <p>Cover the valid outputs</p>
                    <button class="btn-secondary expand-details" data-section="section2">Learn More</button>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <h3>Structural Coverage Sweep</h3>
                    <p>Hunt for blind spots</p>
                    <button class="btn-secondary expand-details" data-section="section3">Learn More</button>
                </div>
                <div class="step">
                    <div class="step-number">4</div>
                    <h3>Suite Refinement</h3>
                    <p>Keep what matters, drop the rest</p>
                    <button class="btn-secondary expand-details" data-section="section4">Learn More</button>
                </div>
            </div>
            
            <!-- Expandable Sections -->
            <div class="expandable-sections">
                <div id="section1" class="section-content hidden">
                    <h3>Robust Boundary-Value Tests - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>This approach primarily follows a "guard the gate" strategy. The idea is to rigorously test the transitions between different behavioral conditions by examining values at and around the boundary points of input ranges. These boundaries often represent moments where the program's logic flips, from accepting to rejecting, from true to false, or from one output to another. Testing right at these borders helps confirm that the logic changes when and where it should.</p>
                            
                            <h4>Key Points</h4>
                            <ul>
                                <li>This is especially important when working with numeric or ordered inputs, where subtle errors, like off-by-one mistakes or incorrect inequality signs, can cause unexpected or inconsistent behavior. Boundary Value Testing doesn't just aim to catch invalid inputs; it ensures the program behaves predictably and correctly around the edges of decision-making logic.
                                </li>
                                <br>
                                <li>To apply this strategy, we systematically test six values per input variable:
                                    <br>
                                <br>Min - 1: Just below the allowed minimum (should be rejected or behave differently)
                                <br>
                                <br>Min: The exact lower boundary (should be accepted)
                                <br>
                                <br>Min + 1: Just above the lower boundary (should be accepted)
                                <br>
                                <br>Max - 1: Just below the upper boundary (should be accepted)
                                <br>
                                <br>Max: The exact upper boundary (should be accepted)
                                <br>
                                <br> Max + 1: Just above the allowed maximum (should be rejected or behave differently)
                                    </li>
                                    <br>
                                <li>This pattern helps verify that the program consistently transitions between states at the correct thresholds and fails gracefully when inputs cross those boundaries. If the program unexpectedly accepts an out-of-range value or rejects a valid boundary value, it likely indicates a logic error that needs further investigation. This systematic method provides clarity and confidence in your program’s behavior, especially around critical decision points.
                                </li>
                            </ul>
                        </div>
                        
                        <div class="table-container">
                            <h4>Example Requirements Analysis</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Requirement</th>
                                        <th>Test Consideration</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>[Requirement 1]</td>
                                        <td>[Test consideration 1]</td>
                                    </tr>
                                    <tr>
                                        <td>[Requirement 2]</td>
                                        <td>[Test consideration 2]</td>
                                    </tr>
                                    <tr>
                                        <td>[Requirement 3]</td>
                                        <td>[Test consideration 3]</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="code-example">
                        <h4>Example Code</h4>
                        <pre><code>
// Example code for understanding requirements
public class Calculator {
    /**
     * Adds two numbers
     * @param a first number
     * @param b second number
     * @return sum of a and b
     */
    public int add(int a, int b) {
        return a + b;
    }
}
                        </code></pre>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="section2" class="section-content hidden">
                    <h3>Edge-Focused Weak Normal Equivalence-Class Test - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>The goal of Equivalence Class Testing (ECT) is to verify that a program behaves correctly across distinct categories of input. Rather than testing every possible value, ECT simplifies the process by dividing the input space into groups, called equivalence classes, where all members of a class are expected to produce the same output or behavior. The underlying assumption is that if one representative value from a class behaves correctly, the rest will too. This allows you to reduce the number of test cases while still covering the full range of program behavior.
                            </p>
                            
                            <h4><strong>Key Points</strong></h4>
                            <ul>
                                <li>While Boundary Value Testing (BVT) focuses on verifying behavior at the edges of individual conditions, ECT complements this by identifying the broader logic that governs those conditions. Instead of testing just around where the program changes behavior (as in BVT), ECT targets the reason why behavior changes. It helps you define the conditions themselves—mapping out where one class of logic flips to another. In this way, ECT simplifies the challenge of designing BVT cases: once the equivalence classes are defined, you know exactly where transitions occur and where to apply more fine-grained boundary checks.
                                </li>
                                <br>
                                <li>To implement ECT effectively, follow these three steps:
                                    <br><br><strong>Partition the input space:</strong> For each input parameter, identify valid and invalid ranges where inputs produce the same type of outcome. Group these into equivalence classes, each defined by producing a unique behavior or result.
                                    <br><br><strong>Select representative values:</strong> Choose values from each equivalence class that represent the typical or defining behavior of that class. Unlike BVT, the goal isn’t to test just inside and outside of a boundary but to test values within each class.
                                    <br><br><strong> Form test case tuples:</strong> If your function takes multiple inputs, create test cases that combine representatives from different equivalence classes. The goal is to ensure that every combination of classes is tested at least once, providing broad behavioral coverage without unnecessary repetition.
                                    </li>
                                <br><li>By designing tests around these representative values and class combinations, you can validate both typical and edge-case behavior while keeping your test suite efficient and targeted. When used alongside BVT, ECT gives you both a high-level map of program logic and the tools to probe its weak points with precision.
                                </li>
                            </ul>
                        </div>
                        
                        <div class="table-container">
                            <h4>Example Test Cases</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Input</th>
                                        <th>Expected Output</th>
                                        <th>Test Case Type</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>[Input 1]</td>
                                        <td>[Expected output 1]</td>
                                        <td>[Type 1]</td>
                                    </tr>
                                    <tr>
                                        <td>[Input 2]</td>
                                        <td>[Expected output 2]</td>
                                        <td>[Type 2]</td>
                                    </tr>
                                    <tr>
                                        <td>[Input 3]</td>
                                        <td>[Expected output 3]</td>
                                        <td>[Type 3]</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="code-example">
                        <h4>Example Code</h4>
                        <pre><code>
// Example test case design
// Test cases for Calculator.add(int a, int b)

// Test case 1: positive numbers
// Input: a=5, b=3
// Expected: 8

// Test case 2: negative numbers
// Input: a=-2, b=-7
// Expected: -9

// Test case 3: mixed sign
// Input: a=10, b=-5
// Expected: 5
                        </code></pre>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="section3" class="section-content hidden">
                    <h3>Structural Coverage Sweep - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>[Detailed content about hunting for blind spots in test coverage]</p>
                            
                            <h4>Key Concepts</h4>
                            <ul>
                                <li>Code coverage identifies untested execution paths</li>
                                <li>Statement coverage: ensure every line runs at least once</li>
                                <li>Branch coverage: ensure every decision (if/else) is tested</li>
                                <li>Path coverage: ensure all possible execution paths are tested</li>
                                <li>Finding blind spots leads to discovering untested edge cases</li>
                            </ul>
                        </div>
                    </div>
                    <div class="button-container">
                        <button class="btn-primary section-close">Close</button>
                        <button class="btn-secondary" id="see-implementation">
                            <i class="fas fa-code"></i> See Implementation
                        </button>
                    </div>
                </div>
                
                <div id="section4" class="section-content hidden">
                    <h3>Suite Refinement - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>[Detailed content about refining test suites]</p>
                            
                            <h4>Key Refinement Strategies</h4>
                            <ul>
                                <li>Eliminate redundant tests that cover the same cases</li>
                                <li>Prioritize tests based on importance and risk</li>
                                <li>Remove tests that don't add value or coverage</li>
                                <li>Combine similar tests for efficiency</li>
                                <li>Organize tests for better maintainability</li>
                            </ul>
                        </div>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="section5" class="section-content hidden">
                    <h3>Approach Limitations in Context</h3>
                    <p class="limitations-intro">Our 4-step approach excels at systematically testing functional correctness, but like all methods, it has specific limitations to consider when planning your testing strategy.</p>
                    
                    <div class="limitations-grid">
                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-sitemap fa-2x"></i>
                            </div>
                            <h4>State-Based System Limitations</h4>
                            <p>This approach works well for pure functions but becomes more complex with stateful systems where the outcome depends on previous operations. Testing state-dependent behavior requires more sophisticated strategies beyond this approach.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> State transition testing, model-based testing
                            </div>
                        </div>
                        
                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-tachometer-alt fa-2x"></i>
                            </div>
                            <h4>Performance Testing Gaps</h4>
                            <p>Our approach focuses primarily on functional correctness rather than performance characteristics. Performance issues like memory leaks, execution time, and resource utilization require specialized testing techniques not covered here.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> Load testing, profiling, benchmarking
                            </div>
                        </div>
                        
                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-user-friends fa-2x"></i>
                            </div>
                            <h4>User Experience Blind Spots</h4>
                            <p>This technique doesn't address usability or experience aspects of software. For user interfaces or interactive systems, additional human-centered testing approaches are necessary to complement this method.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> Usability testing, A/B testing, user feedback
                            </div>
                        </div>
                        
                        <div class="limitation-card">
                            <div class="limitation-icon">
                                <i class="fas fa-shield-alt fa-2x"></i>
                            </div>
                            <h4>Security Testing Insufficiency</h4>
                            <p>While our approach may catch some security issues through boundary testing, it doesn't systematically address security vulnerabilities. Dedicated security testing methodologies should be used alongside this approach for security-critical applications.</p>
                            <div class="limitation-tag">
                                <span>Supplement with:</span> Penetration testing, security code review, threat modeling
                            </div>
                        </div>
                    </div>
                    
                    <p class="limitations-conclusion">By understanding these limitations, you can better determine when to apply this 4-step approach and when to complement it with other testing strategies for comprehensive quality assurance.</p>
                    
                    <button class="btn-primary section-close">Close</button>
                </div>
            </div>
            
            <div class="cta">
                <h2>Ready to See It in Action?</h2>
                <button class="btn-primary" id="see-in-action">See It In Action</button>
            </div>
            
            <div class="limitations-section">
                <h2>Understanding Approach Limitations</h2>
                <p>Even the best testing approaches have constraints. Being aware of these limitations helps you supplement with other testing methods when necessary.</p>
                <div class="limitations-preview">
                    <div class="limitation-preview-item">
                        <i class="fas fa-sitemap"></i>
                        <p>State-Based Systems</p>
                    </div>
                    <div class="limitation-preview-item">
                        <i class="fas fa-tachometer-alt"></i>
                        <p>Performance Aspects</p>
                    </div>
                    <div class="limitation-preview-item">
                        <i class="fas fa-user-friends"></i>
                        <p>User Experience</p>
                    </div>
                    <div class="limitation-preview-item">
                        <i class="fas fa-shield-alt"></i>
                        <p>Security Concerns</p>
                    </div>
                </div>
                <button class="btn-secondary expand-details" data-section="section5">Explore Limitations in Detail</button>
            </div>
        </section>
        
        <!-- Example 1 Page -->
        <section id="example1" class="page">
            <h2>Example 1: MyCar driveCar</h2>
            <div class="example-overview">
                <p>This function is part of a larger program that models a MyCar class, an object-oriented simulation of a car's essential behaviors such as fuel consumption, mileage tracking, and gas refilling. The class includes attributes like fuel efficiency (mpg), gas tank size, total mileage, and gas price, and supports methods that simulate realistic interactions with a car, such as driving, refueling, and maintenance tracking. The driveCar(double miles) method plays a central role in modeling how fuel is consumed when a car is driven. It checks whether the requested number of miles can be driven based on the car’s current gas level and miles-per-gallon efficiency. If the request is valid, it updates the fuel level accordingly and returns true; otherwise, it denies the request and returns false. This simple check ensures that the simulation remains realistic, drivers can’t magically exceed their car’s fuel limits.</p>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">0</div>
                    <h3>Understanding Requirements</h3>
                </div>
                <div class="step-content">
                    <p> For our driveCar function, we need to understand exactly what it should do:</p>
                    
                    <ul>
                        <li>Take one input: a double value representing miles to drive</li>
                        <li>Return a boolean indicating whether the drive was successful</li>
                        <li>Return false if the input miles are negative or exceed the car’s current gas range (mpg × currentGas)</li>
                        <li>Subtract the amount of gas used from currentGas if the drive is possible</li>
                        <li>Return true if the car successfully drives the given distance</li>
                    </ul>
                    
                    <div class="code-example">
                        <h4>The Function We're Testing</h4>
                        <pre><code>
                            public boolean driveCar(double miles){
                                if (miles < 0 || miles > this.mpg*this.currentGas){
                                    return false;
                                }
                                this.currentGas = this.currentGas - (miles/this.mpg);
                                return true;
                            }
                         
                        </code></pre>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3>Step 1: Robust Boundary-Value Tests</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we identify the boundaries where behavior might change and test around those boundaries:</p>
                    <ul>
                        <li>We want to test the boundaries of the variable miles in this function. To do this, we apply the principles of Boundary Value Testing (BVT), which focuses on values at the very edges of a variable’s allowed range—specifically where the program’s behavior transitions from one state to another. Rather than merely identifying out-of-bounds errors, BVT is used to verify that logical conditions flip precisely when they’re supposed to. These transition points might reflect shifts such as false to true, valid to invalid, or rejected to accepted.
                        </li>
                        <li>In order to isolate the behavior of the miles parameter, we’ll fix the other variables in the function to known values. Specifically, we set mpg = 20 and currentGas = 5, which means the maximum drivable distance is 20 * 5 = 100 miles.</li>
                        <li>Now we can systematically test values at and around the key thresholds. Because miles is a double, we can test with precise decimal values, not just whole numbers. This allows us to observe how small variations near those critical boundaries affect program behavior.</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 1</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input (miles) </th>
                                <th>Expected Output</th>
                                <th>Boundary Being Tested</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>BVT1</td>
                                <td>Min - 1: Just below the allowed minimum (should behave differently)</td>
                                <td>FALSE</td>
                                <td>-0.1</td>
                                <td>Just below valid range</td>
                            </tr>
                            <tr>
                                <td>BVT2</td>
                                <td>Min  - The exact lower boundary (should be accepted)</td>
                                <td>0</td>
                                <td>TRUE</td>
                                <td>Lower valid boundary</td>
                            </tr>
                            <tr>
                                <td>BVT3</td>
                                <td>Min + 1  Just above the lower boundary (should be accepted)</td>
                                <td>0.1</td>
                                <td>TRUE</td>
                                <td>Slightly above 0</td>
                            </tr>
                            <tr>
                                <td>BVT4</td>
                                <td>Max - 1 Just below the upper boundary (should be accepted)</td>
                                <td>99.9</td>
                                <td>TRUE</td>
                                <td>Just below max</td>
                            </tr>
                            <tr>
                                <td>BVT5</td>
                                <td>Max The exact upper boundary (should be accepted)</td>
                                <td>100</td>
                                <td>TRUE</td>
                                <td>Upper Valid Boundary</td>
                            </tr>
                            <tr>
                                <td>BVT6</td>
                                <td>Max + 1 Just above the allowed maximum (should behave differently)</td>
                                <td>100.1</td>
                                <td>FALSE</td>
                                <td>Just above the max</td>
                            </tr>
                            
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3>Step 2: Edge-Focused Weak Normal Equivalence-Class Test</h3>
                </div>
                <div class="step-content">
                    <p>Equivalence Class Testing (ECT) involves dividing input values into categories, or “classes,” where all values in a class are expected to produce the same outcome. Rather than testing individual edge values like in BVT, ECT helps ensure the function behaves correctly across broader types of inputs. In the case of driveCar(double miles), we again assume mpg = 20 and currentGas = 5, which means the car can drive a maximum of 100 miles.
                    <br> We can identify the following equivalence classes for the miles input:
                </p>
                    
                    <ul>
                        <li>EC1: Negative input values. Any value less than 0 should be considered invalid and return false.</li>
                        <li>EC2: Valid range values. Any value greater than or equal to 0 but less than or equal to 100 should return true.</li>
                        <li>EC3: Values exceeding the fuel range. Any value greater than 100 should be considered too far to drive and return false.</li><br>
    
                    </ul>
                    
                    <h4>Test Cases Created in Step 2</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input (miles)</th>
                                <th>Expected Output</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>EC1</td>
                                <td>Within EC1 (invalid input)</td>
                                <td>-10</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>EC2</td>
                                <td>Transition from EC1 → EC2</td>
                                <td>0.1</td>
                                <td>TRUE</td>
                            </tr>
                            <tr>
                                <td>EC3</td>
                                <td>Transition from EC2 → EC3</td>
                                <td>150</td>
                                <td>FALSE</td>
                            </tr>

                            </tr>
                        </tbody>
                    </table>
                    <br><p>These test cases verify that the function correctly interprets inputs from within each behavioral region and handles the transitions across class boundaries appropriately.
                        ECT is most effective when used after BVT has exposed where those behavioral boundaries lie. While BVT stresses the inputs right at the turning points—such as 0.0, 100.0, or just beyond, ECT steps back and ensures each logical region on either side of those boundaries is being properly represented and covered.
                        In this way, building one strategy actually helps inform the construction of the other: BVT pinpoints exactly where logic transitions occur, and ECT maps out the broader regions those transitions define. This allows you to test thoroughly without redundancy, using BVT to confirm precision and ECT to ensure consistent coverage across meaningful input classes.
                        </p>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3>Step 3: Structural Coverage Sweep</h3>
                </div>
                <div class="step-content">
                    <p>Using JaCoCo to analyze our code coverage, we identified additional test cases needed:</p>
                    
                    <ul>
                        <li>Test case for Integer.MAX_VALUE boundary: a=Integer.MAX_VALUE, b=1</li>
                        <li>Test case for Integer.MIN_VALUE boundary: a=Integer.MIN_VALUE, b=-1</li>
                        <li>Test case for overflow detection</li>
                    </ul>
                    
                    <div class="placeholder-image">
                        <p>[JaCoCo coverage results image will be added here]</p>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <h3>Step 4: Suite Refinement</h3>
                </div>
                <div class="step-content">
                    <p>After reviewing all our test cases, we've refined our test suite to the following essential tests:</p>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Test Case</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>T1</td>
                                <td>Basic positive</td>
                                <td>a=5, b=3</td>
                                <td>8</td>
                                <td>Core functionality</td>
                            </tr>
                            <tr>
                                <td>T2</td>
                                <td>Both negative</td>
                                <td>a=-2, b=-7</td>
                                <td>-9</td>
                                <td>Sign handling</td>
                            </tr>
                            <tr>
                                <td>T3</td>
                                <td>Mixed signs</td>
                                <td>a=10, b=-5</td>
                                <td>5</td>
                                <td>Sign handling</td>
                            </tr>
                            <tr>
                                <td>T4</td>
                                <td>MAX_VALUE boundary</td>
                                <td>a=MAX_VALUE, b=1</td>
                                <td>Exception</td>
                                <td>Overflow detection</td>
                            </tr>
                            <tr>
                                <td>T5</td>
                                <td>MIN_VALUE boundary</td>
                                <td>a=MIN_VALUE, b=-1</td>
                                <td>Exception</td>
                                <td>Underflow detection</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <p>We eliminated redundant zero-handling tests as they didn't add significant value to the test suite.</p>
                </div>
            </div>
            
            <div class="example-conclusion">
                <h3>Example Summary</h3>
                <p>Our systematic 4-step approach allowed us to create a robust test suite for the calculator function. We identified key boundary conditions and provided essential test coverage while eliminating redundant tests.</p>
            </div>
            
            <div class="cta">
                <button class="btn-primary next-example" data-next="example2">Next Example</button>
            </div>
        </section>
        
        <!-- Example 2 Page -->
        <section id="example2" class="page">
            <h2>Example 2: String Validator</h2>
            <div class="example-overview">
                <p>In this example, we'll apply our 4-step approach to test a string validation function that checks if a string meets certain criteria.</p>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">0</div>
                    <h3>Understanding Requirements</h3>
                </div>
                <div class="step-content">
                    <p>For our string validator, we need to understand the validation rules:</p>
                    
                    <ul>
                        <li>String must be between 8 and 20 characters long</li>
                        <li>String must contain at least one uppercase letter</li>
                        <li>String must contain at least one digit</li>
                        <li>String must not contain spaces</li>
                    </ul>
                    
                    <div class="code-example">
                        <h4>The Function We're Testing</h4>
                        <pre><code>
public class StringValidator {
    /**
     * Validates a string according to specific rules
     * @param input the string to validate
     * @return true if the string is valid, false otherwise
     */
    public boolean isValid(String input) {
        // Check length
        if (input == null || input.length() < 8 || input.length() > 20) {
            return false;
        }
        
        // Check for uppercase letter
        boolean hasUppercase = false;
        // Check for digit
        boolean hasDigit = false;
        // Check for spaces
        boolean hasSpace = false;
        
        for (char c : input.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUppercase = true;
            }
            if (Character.isDigit(c)) {
                hasDigit = true;
            }
            if (Character.isWhitespace(c)) {
                hasSpace = true;
            }
        }
        
        return hasUppercase && hasDigit && !hasSpace;
    }
}
                        </code></pre>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3>Step 1: Robust Boundary-Value Tests</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we focus on testing the boundaries specified in the requirements:</p>
                    
                    <ul>
                        <li>We test the minimum and maximum length boundaries (8 and 20 characters)</li>
                        <li>We test exactly at the boundaries (8 characters, 20 characters)</li>
                        <li>We test just outside the boundaries (7 characters, 21 characters)</li>
                        <li>We test special cases like null input</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 1</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Boundary Being Tested</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>BVT1</td>
                                <td>Null input</td>
                                <td>null</td>
                                <td>false</td>
                                <td>Special null case</td>
                            </tr>
                            <tr>
                                <td>BVT2</td>
                                <td>Exactly minimum length</td>
                                <td>"Abcde123" (8 chars)</td>
                                <td>true</td>
                                <td>Minimum length boundary</td>
                            </tr>
                            <tr>
                                <td>BVT3</td>
                                <td>Just under minimum length</td>
                                <td>"Abcde12" (7 chars)</td>
                                <td>false</td>
                                <td>Below minimum length</td>
                            </tr>
                            <tr>
                                <td>BVT4</td>
                                <td>Exactly maximum length</td>
                                <td>"Abcdefghij1234567890" (20 chars)</td>
                                <td>true</td>
                                <td>Maximum length boundary</td>
                            </tr>
                            <tr>
                                <td>BVT5</td>
                                <td>Just over maximum length</td>
                                <td>"Abcdefghij12345678901" (21 chars)</td>
                                <td>false</td>
                                <td>Above maximum length</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3>Step 2: Edge-Focused Weak Normal Equivalence-Class Test</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we create test cases for different categories of valid and invalid inputs based on the other requirements:</p>
                    
                    <ul>
                        <li>We test combinations of requirements (uppercase, digit, no spaces)</li>
                        <li>We create tests for each failing condition</li>
                        <li>We ensure all validation rules are individually tested</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 2</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Equivalence Class</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>EC1</td>
                                <td>Valid input - all requirements met</td>
                                <td>"Password123"</td>
                                <td>true</td>
                                <td>Valid string</td>
                            </tr>
                            <tr>
                                <td>EC2</td>
                                <td>Missing uppercase letter</td>
                                <td>"password123"</td>
                                <td>false</td>
                                <td>Missing uppercase requirement</td>
                            </tr>
                            <tr>
                                <td>EC3</td>
                                <td>Missing digit</td>
                                <td>"PasswordTest"</td>
                                <td>false</td>
                                <td>Missing digit requirement</td>
                            </tr>
                            <tr>
                                <td>EC4</td>
                                <td>Contains space</td>
                                <td>"Password 123"</td>
                                <td>false</td>
                                <td>Contains forbidden character</td>
                            </tr>
                            <tr>
                                <td>EC5</td>
                                <td>Special characters (allowed)</td>
                                <td>"P@ssw0rd#$!"</td>
                                <td>true</td>
                                <td>Valid with special characters</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3>Step 3: Structural Coverage Sweep</h3>
                </div>
                <div class="step-content">
                    <p>Using JaCoCo to analyze our code coverage, we identified additional test cases needed:</p>
                    
                    <ul>
                        <li>Test case where only the space check fails (other conditions pass)</li>
                        <li>Test case for input with both uppercase and digits but no other requirements</li>
                        <li>Test for early return conditions in sequence</li>
                    </ul>
                    
                    <div class="placeholder-image">
                        <p>[JaCoCo coverage results image will be added here]</p>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <h3>Step 4: Suite Refinement</h3>
                </div>
                <div class="step-content">
                    <p>After reviewing all our test cases, we've refined our test suite to the following essential tests:</p>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>RT1</td>
                                <td>Valid string</td>
                                <td>"Password123"</td>
                                <td>true</td>
                                <td>Valid case verification</td>
                            </tr>
                            <tr>
                                <td>RT2</td>
                                <td>Null input</td>
                                <td>null</td>
                                <td>false</td>
                                <td>Special case handling</td>
                            </tr>
                            <tr>
                                <td>RT3</td>
                                <td>Length boundary - too short</td>
                                <td>"Abc1"</td>
                                <td>false</td>
                                <td>Minimum length verification</td>
                            </tr>
                            <tr>
                                <td>RT4</td>
                                <td>Length boundary - too long</td>
                                <td>"Abcdefghij1234567890X"</td>
                                <td>false</td>
                                <td>Maximum length verification</td>
                            </tr>
                            <tr>
                                <td>RT5</td>
                                <td>Missing uppercase</td>
                                <td>"password123"</td>
                                <td>false</td>
                                <td>Uppercase requirement</td>
                            </tr>
                            <tr>
                                <td>RT6</td>
                                <td>Missing digit</td>
                                <td>"PasswordTest"</td>
                                <td>false</td>
                                <td>Digit requirement</td>
                            </tr>
                            <tr>
                                <td>RT7</td>
                                <td>Contains space</td>
                                <td>"Password 123"</td>
                                <td>false</td>
                                <td>No-space requirement</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <p>We eliminated some redundant test cases and focused on a minimal set that still provides 100% code coverage.</p>
                </div>
            </div>
            
            <div class="example-conclusion">
                <h3>Example Summary</h3>
                <p>Our systematic 4-step approach allowed us to create a comprehensive test suite for the string validator. We identified key validation boundaries and provided complete coverage of all validation rules while avoiding redundant tests.</p>
            </div>
            
            <div class="cta">
                <button class="btn-primary next-example" data-next="example3">Next Example</button>
            </div>
        </section>
        
        <!-- Example 3 Page -->
        <section id="example3" class="page">
            <h2>Example 3: File Processing Library</h2>
            <div class="example-overview">
                <p>In this example, we'll apply our 4-step approach to test a file processing library that reads and processes data files.</p>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">0</div>
                    <h3>Understanding Requirements</h3>
                </div>
                <div class="step-content">
                    <p>For our file processing library, we need to understand the requirements:</p>
                    
                    <ul>
                        <li>Must read CSV files with comma-separated values</li>
                        <li>Must handle empty files and files with headers</li>
                        <li>Must convert string data to appropriate types (integers, doubles)</li>
                        <li>Must handle file errors gracefully (file not found, permission denied)</li>
                        <li>Must allow filtering and sorting of data</li>
                    </ul>
                    
                    <div class="code-example">
                        <h4>The Class We're Testing</h4>
                        <pre><code>
public class CSVProcessor {
    /**
     * Reads a CSV file and returns processed data
     * @param filePath the path to the CSV file
     * @param hasHeader whether the file has a header row
     * @return DataTable containing the processed data
     * @throws IOException if there's an error reading the file
     */
    public DataTable readCSV(String filePath, boolean hasHeader) throws IOException {
        File file = new File(filePath);
        if (!file.exists() || !file.canRead()) {
            throw new IOException("File does not exist or cannot be read: " + filePath);
        }
        
        DataTable table = new DataTable();
        BufferedReader reader = new BufferedReader(new FileReader(file));
        
        // Read header if present
        String line = reader.readLine();
        if (line == null) {
            reader.close();
            return table; // Empty file
        }
        
        if (hasHeader) {
            String[] headers = line.split(",");
            table.setHeaders(headers);
            line = reader.readLine();
        }
        
        // Read data rows
        while (line != null) {
            String[] values = line.split(",");
            table.addRow(values);
            line = reader.readLine();
        }
        
        reader.close();
        return table;
    }
    
    // Other methods for filtering, sorting, etc.
}
                        </code></pre>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3>Step 1: Robust Boundary-Value Tests</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we identify boundary conditions for our CSV processor:</p>
                    
                    <ul>
                        <li>File existence and access boundaries (exists vs doesn't exist, readable vs not readable)</li>
                        <li>File content boundaries (empty file, single line, very large file)</li>
                        <li>Header presence boundary (with header vs without header)</li>
                        <li>Special case boundaries (malformed data, invalid paths)</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 1</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Boundary Being Tested</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>BVT1</td>
                                <td>File doesn't exist</td>
                                <td>"nonexistent.csv", true</td>
                                <td>IOException</td>
                                <td>File existence boundary</td>
                            </tr>
                            <tr>
                                <td>BVT2</td>
                                <td>Empty file</td>
                                <td>"empty.csv", true</td>
                                <td>Empty DataTable</td>
                                <td>Empty content boundary</td>
                            </tr>
                            <tr>
                                <td>BVT3</td>
                                <td>Single line file with header</td>
                                <td>"singleline.csv", true</td>
                                <td>DataTable with headers, no data</td>
                                <td>Minimum content with header</td>
                            </tr>
                            <tr>
                                <td>BVT4</td>
                                <td>Single line file without header</td>
                                <td>"singleline.csv", false</td>
                                <td>DataTable with one data row</td>
                                <td>Minimum content without header</td>
                            </tr>
                            <tr>
                                <td>BVT5</td>
                                <td>No read permission</td>
                                <td>"nopermission.csv", true</td>
                                <td>IOException</td>
                                <td>File permission boundary</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3>Step 2: Edge-Focused Weak Normal Equivalence-Class Test</h3>
                </div>
                <div class="step-content">
                    <p>In this step, we identify categories of valid inputs and design one test case for each category:</p>
                    
                    <ul>
                        <li>We categorize different valid file formats and content types</li>
                        <li>We test representative files from each category</li>
                        <li>We ensure normal operation cases are covered</li>
                    </ul>
                    
                    <h4>Test Cases Created in Step 2</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Equivalence Class</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>EC1</td>
                                <td>Standard CSV with header</td>
                                <td>"standard.csv", true</td>
                                <td>DataTable with headers and rows</td>
                                <td>Standard CSV with header</td>
                            </tr>
                            <tr>
                                <td>EC2</td>
                                <td>Standard CSV without header</td>
                                <td>"standard.csv", false</td>
                                <td>DataTable with rows, no headers</td>
                                <td>Standard CSV without header</td>
                            </tr>
                            <tr>
                                <td>EC3</td>
                                <td>CSV with numeric data only</td>
                                <td>"numeric.csv", true</td>
                                <td>DataTable with numeric values</td>
                                <td>Numeric data CSV</td>
                            </tr>
                            <tr>
                                <td>EC4</td>
                                <td>CSV with text data only</td>
                                <td>"text.csv", true</td>
                                <td>DataTable with text values</td>
                                <td>Text data CSV</td>
                            </tr>
                            <tr>
                                <td>EC5</td>
                                <td>CSV with mixed data types</td>
                                <td>"mixed.csv", true</td>
                                <td>DataTable with mixed values</td>
                                <td>Mixed data CSV</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3>Step 3: Structural Coverage Sweep</h3>
                </div>
                <div class="step-content">
                    <p>Using JaCoCo to analyze our code coverage, we identified additional test cases needed:</p>
                    
                    <ul>
                        <li>Test case with malformed CSV (inconsistent column count)</li>
                        <li>Test case with special characters in CSV data</li>
                        <li>Test case for the file reading exception handling paths</li>
                    </ul>
                    
                    <div class="placeholder-image">
                        <p>[JaCoCo coverage results image will be added here]</p>
                    </div>
                </div>
            </div>
            
            <div class="approach-step">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <h3>Step 4: Suite Refinement</h3>
                </div>
                <div class="step-content">
                    <p>After reviewing all our test cases, we've refined our test suite to the following essential tests:</p>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Test ID</th>
                                <th>Description</th>
                                <th>Input</th>
                                <th>Expected Output</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>RT1</td>
                                <td>Valid file with header</td>
                                <td>"data.csv", true</td>
                                <td>Correct DataTable</td>
                                <td>Basic functionality with header</td>
                            </tr>
                            <tr>
                                <td>RT2</td>
                                <td>Valid file without header</td>
                                <td>"data.csv", false</td>
                                <td>Correct DataTable</td>
                                <td>Basic functionality without header</td>
                            </tr>
                            <tr>
                                <td>RT3</td>
                                <td>Empty file</td>
                                <td>"empty.csv", true</td>
                                <td>Empty DataTable</td>
                                <td>Empty file handling</td>
                            </tr>
                            <tr>
                                <td>RT4</td>
                                <td>File not found</td>
                                <td>"nonexistent.csv", true</td>
                                <td>IOException</td>
                                <td>Error handling</td>
                            </tr>
                            <tr>
                                <td>RT5</td>
                                <td>Malformed CSV</td>
                                <td>"malformed.csv", true</td>
                                <td>Exception or handling</td>
                                <td>Malformed data handling</td>
                            </tr>
                            <tr>
                                <td>RT6</td>
                                <td>File with special characters</td>
                                <td>"special.csv", true</td>
                                <td>Correct DataTable</td>
                                <td>Special character handling</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <p>We eliminated redundant test cases focusing on a minimal set that ensures all execution paths are covered.</p>
                </div>
            </div>
            
            <div class="example-conclusion">
                <h3>Example Summary</h3>
                <p>Our systematic 4-step approach allowed us to create a robust test suite for the CSV processor. We identified boundary conditions, provided comprehensive coverage of both normal and error cases, and developed effective error handling strategies.</p>
            </div>
        </section>
        
        <!-- Advanced Page -->
        <section id="advanced" class="page">
            <h2>Advanced Testing Techniques</h2>
            <div class="step-overview">
                <div class="step">
                    <div class="step-number">1</div>
                    <h3>Setting Up JUnit</h3>
                    <p>[Overview of JUnit setup]</p>
                    <button class="btn-secondary expand-details" data-section="advanced1">Learn More</button>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <h3>JaCoCo Code Coverage</h3>
                    <p>[Overview of JaCoCo]</p>
                    <button class="btn-secondary expand-details" data-section="advanced2">Learn More</button>
                </div>
            </div>
            
            <!-- Expandable Sections -->
            <div class="expandable-sections">
                <div id="advanced1" class="section-content hidden">
                    <h3>Setting Up JUnit - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>[Detailed content about setting up and using JUnit]</p>
                            
                            <h4>Key Features</h4>
                            <ul>
                                <li>[Feature 1]</li>
                                <li>[Feature 2]</li>
                                <li>[Feature 3]</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="code-example">
                        <h4>Example Code</h4>
                        <pre><code>
// JUnit example code
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class CalculatorJUnitTest {
    @Test
    public void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(8, calc.add(5, 3));
        assertEquals(-9, calc.add(-2, -7));
        assertEquals(5, calc.add(10, -5));
    }
}
                        </code></pre>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
                
                <div id="advanced2" class="section-content hidden">
                    <h3>JaCoCo Code Coverage - Detailed</h3>
                    <div class="content-container">
                        <div class="text-content">
                            <p>[Detailed content about setting up and using JaCoCo]</p>
                            
                            <h4>Benefits of Code Coverage</h4>
                            <ul>
                                <li>[Benefit 1]</li>
                                <li>[Benefit 2]</li>
                                <li>[Benefit 3]</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="code-example">
                        <h4>Configuration Example</h4>
                        <pre><code>
// JaCoCo Gradle configuration
plugins {
    id 'jacoco'
}

jacoco {
    toolVersion = "0.8.7"
}

jacocoTestReport {
    reports {
        xml.enabled true
        html.enabled true
    }
}
                        </code></pre>
                    </div>
                    <button class="btn-primary section-close">Close</button>
                </div>
            </div>
        </section>
    </main>
    
    <footer>
        <div class="footer-content">
            <p>&copy; 2025 COSC 102 Testing Guide</p>
            <p>Created for educational purposes</p>
        </div>
    </footer>
    
    <script src="assets/js/main.js"></script>
</body>
</html>